@using Splitracker.Web.Domain
@using System.Text.RegularExpressions

<MudStack
    Class="ty-PointsEditor">
    <PointsPreview
        LineCapacity="@LineCapacity"
        TotalCapacity="@TotalCapacity"
        TotalCurrentPoints="@totalCurrentPoints"
        Points="@Value"
        ShowPenalties="@false"
        />
    <div>
        <label>
            <MudTextField
                @bind-Value="expression"
                Label="Punkte"
                Variant="Variant.Outlined"
                HelperText="z.B. +K3V1-E2"
                autocomplete="off"
                enterkeyhind="send"
                @onkeyup="textFieldKeyUp"
                Pattern="([KEVkev0-9+-]|\s)*"
                Clearable
                Immediate @ref="textField"/>
        </label>
    </div>
    <div>
        <MudButton
            @onclick="toggleType">
            <p>
                <PointDisplay
                    Type="type"/>
            </p>
            <p>(wechseln)</p>
        </MudButton>
        @{
            var preview = limitsFor(Value);
        }
        <MudSlider
            T="int"
            Value="@primaryPointValue"
            ValueChanged="@onSlide"
            Min="@preview.Min"
            Max="@preview.Max"
            Variant="Variant.Filled"
            Size="Size.Medium">
            min=@preview.Min max=@preview.Max
        </MudSlider>
    </div>
</MudStack>

@code {

    MudTextField<string>? textField;

    public PointsVec Value
    {
        get => value;
        set
        {
            this.value = value;
            type = inferType(value);
        }
    }

    [Parameter]
    public EventCallback<PointsVec> ValueChanged { get; set; }

    [Parameter]
    [EditorRequired]
    public int LineCapacity { get; set; }

    [Parameter]
    [EditorRequired]
    public int TotalCapacity { get; set; }

    [Parameter]
    [EditorRequired]
    public PointsVec CurrentPoints { get; set; }

    [Parameter]
    public EventCallback<PointsVec> PointsApplied { get; set; }

    private PointType type = PointType.V;
    private PointsVec value;

    private int totalCurrentPoints => CurrentPoints.Channeled + CurrentPoints.Exhausted + CurrentPoints.Consumed;

    string expression
    {
        get => Value.ToString();
        set => Value = PointsVec.From(value, type).Collapse();
    }

    private int primaryPointValue
    {
        get => Value[type];
        set => Value = PointsVec.From(value, type);
    }

    private void toggleType()
    {
        var nextType = type switch {
            PointType.K => PointType.E,
            PointType.E => PointType.V,
            PointType.V => PointType.K,
            _ => throw new ArgumentOutOfRangeException()
            };

        var inferredValue = PointsVec.From(Value.Channeled + Value.Consumed + Value.Exhausted, nextType);
        Value = inferredValue;
        type = nextType;
    }

    private (int Min, int Max) limitsFor(in PointsVec nextValue)
    {
        var maxAmount = Math.Max(0, TotalCapacity - totalCurrentPoints);
        var minAmount = Math.Min(0, -CurrentPoints[inferType(nextValue)]);
        return (minAmount, maxAmount);
    }

    private PointType inferType(in PointsVec vec)
    {
        var k = Math.Abs(vec.Channeled);
        var e = Math.Abs(vec.Exhausted);
        var v = Math.Abs(vec.Consumed);
        return k >= e && k >= v ? PointType.K : e >= v ? PointType.E : PointType.V;
    }

    private void onSlide(int newValue)
    {
        Value = PointsVec.From(newValue, type);
    }

    async Task textFieldKeyUp(KeyboardEventArgs obj)
    {
        if (obj.Key == "Enter")
        {
            if (textField != null)
            {
                await textField.BlurAsync();
            }
            await PointsApplied.InvokeAsync(Value);
            Value = default;
            if (textField != null)
            {
                await textField.FocusAsync();
            }
        }
    }

}