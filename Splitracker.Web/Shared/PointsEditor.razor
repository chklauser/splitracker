@using System.Text.RegularExpressions
@using System.Diagnostics.CodeAnalysis
@using Splitracker.Domain

<MudStack
    Class="ty-PointsEditor"
    Spacing="1">
    <div
        class="mx-auto">
        <PointsPreview
            LineCapacity="@LineCapacity"
            TotalCapacity="@TotalCapacity"
            TotalCurrentPoints="@totalCurrentPoints"
            Points="@Value.Collapse()"
            ShowPenalties="@false"/>
    </div>
    <MudTextField
        T="string"
        @bind-Text="expression"
        Label="Punkte"
        Variant="Variant.Outlined"
        HelperText="z.B. +K3V1-E2"
        autocomplete="off"
        enterkeyhind="send"
        @onkeyup="textFieldKeyUp"
        Pattern="([KEVkev0-9+-]|\s)*"
        FullWidth
        Clearable
        Immediate
        @ref="textField"/>
    <MudStack
        Spacing="6"
        Row="true"
        Justify="Justify.SpaceAround"
        AlignItems="AlignItems.Center">
        <MudButton
            @onclick="toggleType"
            Variant="Variant.Filled">
            <MudStack
                Spacing="1"
                Justify="Justify.SpaceAround"
                AlignItems="AlignItems.Center">
                <PointDisplay
                    Type="type"/>
                <MudText>(wechseln)</MudText>
            </MudStack>
        </MudButton>
        @{
            var preview = limitsFor(Value);
        }
        <MudSlider
            T="int"
            Value="@primaryPointValue"
            ValueChanged="@onSlide"
            Min="@preview.Min"
            Max="@preview.Max"
            Variant="Variant.Filled"
            Size="Size.Medium">
            <!-- min=@preview.Min max=@preview.Max -->
        </MudSlider>
    </MudStack>
</MudStack>

@code {

    MudTextField<string>? textField;

    public PointsVec Value
    {
        get => value;
        set
        {
            this.value = value;
            if (!value.IsZero)
            {
                type = inferType(value);
            }
            if (PointsVec.From(expression, type) != value)
            {
                _expression = Value.ToString();
            }
        }
    }

    [Parameter]
    public EventCallback<PointsVec> ValueChanged { get; set; }

    [Parameter]
    [EditorRequired]
    public int LineCapacity { get; set; }

    [Parameter]
    [EditorRequired]
    public int TotalCapacity { get; set; }

    [Parameter]
    [EditorRequired]
    public PointsVec CurrentPoints { get; set; }

    [Parameter]
    public EventCallback<PointsVec> PointsApplied { get; set; }

    private PointType type = PointType.V;
    private PointsVec value;

    private int totalCurrentPoints => CurrentPoints.Channeled + CurrentPoints.Exhausted + CurrentPoints.Consumed;

    [SuppressMessage("ReSharper", "InconsistentNaming")] string _expression = string.Empty;

    string expression
    {
        get => _expression;
        set
        {
            _expression = value;
            var vec = PointsVec.From(value, type);
            if (vec != Value)
            {
                Value = vec;
            }
        }
    }

    private int primaryPointValue
    {
        get => Value[type];
        set => Value = PointsVec.From(value, type);
    }

    private void toggleType()
    {
        var nextType = type switch {
            PointType.K => PointType.E,
            PointType.E => PointType.V,
            PointType.V => PointType.K,
            _ => throw new ArgumentOutOfRangeException()
            };

        var inferredValue = PointsVec.From(Value.Channeled + Value.Consumed + Value.Exhausted, nextType);
        Value = inferredValue;
        type = nextType;
    }

    private (int Min, int Max) limitsFor(in PointsVec nextValue)
    {
        var maxAmount = Math.Max(0, TotalCapacity - totalCurrentPoints);
        var minAmount = Math.Min(0, -CurrentPoints[type]);
        return (minAmount, maxAmount);
    }

    private PointType inferType(in PointsVec vec)
    {
        var k = Math.Abs(vec.Channeled);
        var e = Math.Abs(vec.Exhausted);
        var v = Math.Abs(vec.Consumed);
        return k >= e && k >= v ? PointType.K : e >= v ? PointType.E : PointType.V;
    }

    private void onSlide(int newValue)
    {
        Value = PointsVec.From(newValue, type);
    }

    async Task textFieldKeyUp(KeyboardEventArgs obj)
    {
        if (obj.Key == "Enter")
        {
            if (textField != null)
            {
                await textField.BlurAsync();
            }
            await PointsApplied.InvokeAsync(Value);
            Value = default;
            if (textField != null)
            {
                await textField.FocusAsync();
            }
        }
    }

}