@using Splitracker.Domain

@code {
    
}

@if (allocatedTimeline == null)
{
    <MudProgressCircular Color="Color.Primary"/>
}
else
{
    <MultiTimeline
        DisableModifiers="@true"
        TimelinePosition="@TimelinePosition.Alternate"
        TimelineAlign="@TimelineAlign.Start"
        Labels="@timelineLabels()"
        @bind-SelectedIndex:get="selectedIndex"
        @bind-SelectedIndex:set="changeSelectedIndex"
        @onclick="timelineClicked">
        @foreach (var lengths in allocatedTimeline.GroupBy(y => y.Track, y => y.Offset + 1))
        {
            var track = lengths.Key;
            <MultiTimelineTrack
                @key="@track"
                Index="@track"
                Lengths="@(track == 0 ? new[]{allocatedTimeline.Count} : lengths)"/>
        }
        @foreach (var (tick, track, offset) in allocatedTimeline)
        {
            @if (tick is not Empty)
            {
                <MultiTimelineItem
                    @key="tick.ToString()"
                    Track="@track"
                    Offset="@offset"
                    Size="@Size.Medium"
                    Color="@(offset == selectedIndex ? Color.Primary : Color.Default)">
                    <ItemDot>
                        @if (tick is Tick.CharacterTick { Character: var c})
                        {
                            <CharacterAvatar Character="@c" Selected="@(offset == selectedIndex)" ShowPenalty="@true" />
                        }
                        else if (tick is Tick.EffectTick)
                        {
                            <MudIcon
                                Color="@(offset == selectedIndex ? Color.Default : Color.Dark)"
                                Icon="@Icons.Material.Filled.CrisisAlert"/>
                        }
                    </ItemDot>
                    <ItemContent>
                        <MudPopover AnchorOrigin="@Origin.TopCenter" TransformOrigin="@Origin.BottomCenter"
                                    OverflowBehavior="OverflowBehavior.FlipOnOpen" Open="@(actionCardOpen && selectedIndex == offset)">
                            @if (tick is Tick.CharacterTick ct)
                            {
                                <TimelineCharacterActionCard 
                                    Tick="ct"
                                    Permissions="@Permissions[ct.Character.Id]"
                                    IsReadyNow="@(offset == 0)"
                                    CanReact="@(offset - allocatedTimeline[0].Tick.At < 30)"
                                    @bind-ActionData:get="getCharacterActionData(ct.Character)"
                                    @bind-ActionData:set="data => storeCharacterActionData(ct.Character, data)"
                                    OnApplyActionClicked="d => characterActionApplyClicked(d, ct.Character)"
                                    OnCloseButtonClicked="() => actionCardOpen = false"
                                    />
                            }
                            else if (tick is Tick.EffectTick et)
                            {
                                <CascadingValue TValue="ITimelineDispatcher" Value="@Dispatcher" IsFixed="@true">
                                    <TimelineEffectActionCard Tick="et" IsHappeningNow="@(offset == 0)" OnCloseButtonClicked="() => actionCardOpen = false" />
                                </CascadingValue>
                            }
                        </MudPopover>
                        <TickSummary
                            Tick="@tick"/>
                    </ItemContent>
                </MultiTimelineItem>
            }
            else
            {
                <MultiTimelineItem
                    @key="@($"synth-tick:{tick.At}")"
                    Track="@track"
                    Offset="@offset"
                    Size="@Size.Small"
                    Variant="Variant.Outlined"
                    Color="@(offset == selectedIndex ? Color.Primary : Color.Default)"/>
            }
        }
    </MultiTimeline>
}