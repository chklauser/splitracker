@using Splitracker.Domain
@using Splitracker.Domain.Commands
@using System.Diagnostics.CodeAnalysis

@implements IDisposable
@implements ICharacterCommandRouter
@inject ICharacterRepository repository

<CascadingValue TValue="ICharacterCommandRouter" IsFixed="true" Value="@this">
  <MudCard
    Class="CharacterCard">
    <MudCardHeader
        Class="pb-0">
        <CardHeaderContent>
            @if (EditMode)
            {
                <MudTextField
                    @bind-Value="newName"
                    Label="Name"
                    Required
                    RequiredError="Jeder braucht einen Namen!"/>
            }
            else
            {
                <MudText
                    Typo="Typo.h4">
                    @character.Name
                </MudText>
            }
        </CardHeaderContent>
        <CardHeaderActions>
            @if (EditMode)
            {
                <MudIconButton
                    Icon="@Icons.Material.Filled.Delete"
                    Color="Color.Secondary"
                    @onclick="deleteAsync"/>
            }
        </CardHeaderActions>
    </MudCardHeader>
    <MudCardContent
        Class="pt-0">
        @if (EditMode)
        {
            <MudGrid
                Justify="Justify.FlexStart">
                <MudItem
                    xs="9">
                    <MudNumericField
                        Label="LP"
                        @bind-Value="newLpBaseCapacity"
                        Min="1"
                        Max="20"
                        Required/>
                </MudItem>
                <MudItem
                    xs="3">
                    <MudText>=&nbsp;@(newLpBaseCapacity * 5)</MudText>
                </MudItem>
                <MudItem
                    xs="9">
                    <MudNumericField
                        Label="FO"
                        @bind-Value="newFoBaseCapacity"
                        Min="1"
                        Max="@(12 * 5)"
                        Required/>
                </MudItem>
            </MudGrid>
        }
        else
        {
            <MudTabs
                KeepPanelsAlive="true" TabPanelClass="CharacterTab">
                <PoolEditor
                    Title="Leben"
                    Icon="@Icons.Material.Filled.Shield"
                    TotalCapacity="@(c => c * 5)"
                    LineCapacity="@(c => c)"
                    Pool="@character.Lp"
                    ShowPenalties
                    Type="@PoolType.Lp" />
                <PoolEditor
                    Title="Fokus"
                    Icon="@Icons.Material.Filled.Nightlight"
                    TotalCapacity="@(c => c)"
                    LineCapacity="@(_ => 12)"
                    Pool="@character.Fo"
                    Type="@PoolType.Fo" />
            </MudTabs>
        }
    </MudCardContent>
    @if (EditMode)
    {
        <MudCardActions>
            <MudStack
                Row
                AlignItems="AlignItems.Center"
                Justify="Justify.SpaceEvenly">
                @if (character.Id != "")
                {
                    <MudButton
                        EndIcon="@Icons.Material.Filled.ContentCopy"
                        Color="@Color.Tertiary"
                        @onclick="cloneAsync">
                        Klonen
                    </MudButton>
                }
                <MudButton
                    EndIcon="@Icons.Material.Filled.Save"
                    Disabled="@(!hasChanges)"
                    Color="@Color.Primary"
                    @onclick="saveAsync">
                    Speichern
                </MudButton>
            </MudStack>
        </MudCardActions>
    }
</MudCard>
</CascadingValue>

@code {

    [Parameter]
    [EditorRequired]
    public required ICharacterHandle CharacterHandle { get; set; }

    [CascadingParameter]
    public required ICharacterCommandRouter OuterCommandRouter { get; set; }

    ICharacterHandle? lastHandle;

    Character character => CharacterHandle.Character;

    [Parameter]
    [EditorRequired]
    public required bool EditMode { get; set; }

    private string newName = string.Empty;
    private int newLpBaseCapacity;
    private int newFoBaseCapacity;

    protected override void OnParametersSet()
    {
        clearHandleCallbacks();

        base.OnParametersSet();
        newName = character.Name;
        newLpBaseCapacity = character.Lp.BaseCapacity;
        newFoBaseCapacity = character.Fo.BaseCapacity;
        lastHandle = CharacterHandle;
        CharacterHandle.CharacterUpdated += handleCharacterUpdated;
    }

    private bool hasChanges =>
        character.Id == ""
            || newName != character.Name
            || newLpBaseCapacity != character.Lp.BaseCapacity
            || newFoBaseCapacity != character.Fo.BaseCapacity;

    public void Dispose()
    {
        clearHandleCallbacks();
    }

    void clearHandleCallbacks()
    {
        if (lastHandle is { } prevHandle)
        {
            prevHandle.CharacterUpdated -= handleCharacterUpdated;
        }

        if (CharacterHandle is { } handle)
        {
            handle.CharacterUpdated -= handleCharacterUpdated;
        }
    }

    void handleCharacterUpdated(object? sender, EventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    [SuppressMessage("ReSharper", "WithExpressionModifiesAllMembers")]
    public async Task ApplyAsync(ICharacterCommand command)
    {
        command = command switch {
            ApplyPoints applyPoints => applyPoints with{ CharacterId = character.Id},
            EditCharacter editCharacter => editCharacter with { CharacterId = character.Id},
            Domain.Commands.StopChanneling releaseChanneling => releaseChanneling with { CharacterId = character.Id},
            Domain.Commands.ShortRest shortRest => shortRest with { CharacterId = character.Id},
            DeleteCharacter deleteCharacter => deleteCharacter with { CharacterId = character.Id},
            CloneCharacter cloneCharacter => cloneCharacter with { CharacterId = character.Id},
            _ => throw new ArgumentOutOfRangeException(nameof(command))
            };
        await OuterCommandRouter.ApplyAsync(command);
    }

    async Task saveAsync()
    {
        await ApplyAsync(new EditCharacter(null!, newName, newLpBaseCapacity, newFoBaseCapacity));
    }

    async Task cloneAsync()
    {
        await ApplyAsync(new CloneCharacter(null!));
    }

    async Task deleteAsync()
    {
        await ApplyAsync(new DeleteCharacter(null!));
    }

}