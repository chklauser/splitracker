@using Splitracker.Domain
@using Splitracker.Domain.Commands
@using System.Diagnostics.CodeAnalysis
@using System.Collections.Immutable
@using MudBlazor.Utilities

@implements IDisposable
@implements ICharacterCommandRouter
@inject NavigationManager nav

@if (Permissions.HasFlag(CharacterPermissions.ViewStats))
{
    <CascadingValue
        TValue="ICharacterCommandRouter"
        IsFixed="true"
        Value="@this">
        <MudCard
            Class="CharacterCard">
            <MudCardHeader
                Class="pb-0">
                <CardHeaderAvatar>
                    <CharacterAvatar
                        Elevation="2"
                        Character="@character"/>
                </CardHeaderAvatar>
                <CardHeaderContent>
                    <MudText
                        Typo="Typo.h4">
                        @character.Name
                    </MudText>
                </CardHeaderContent>
                <CardHeaderActions>
                    @if (Permissions.HasFlag(CharacterPermissions.EditStats))
                    {
                        <MudIconButton
                            Icon="@Icons.Material.Filled.Edit"
                            Color="Color.Primary"
                            @onclick="gotoEdit"/>
                    }
                </CardHeaderActions>
            </MudCardHeader>
            <MudCardContent
                Class="pt-0">
                
                    @if (character.SplinterPoints.Max > 0)
                    {
                    
                        for(var i = 0; i < character.SplinterPoints.Max; i++)
                        {
                            var available = i < character.SplinterPoints.Remaining;
                            <MudTooltip Text="@(available ? "Splitterpunkt einsetzen" : "Splitterpunkt bereits eingesetzt")">
                                <MudIconButton
                                    Icon="@Icons.Material.TwoTone.Brightness3"
                                    Color="@(available ? Color.Default : Color.Dark)"
                                    Disabled="@(!available)" 
                                    OnClick="useSplinterPointAsync"/>
                            </MudTooltip>
                        }
                        <MudTooltip Text="@(character.SplinterPoints.Used == 0 ? "Splitterpunktemaximum erreicht" : "Splitterpunkte zurücksetzen")">
                            <MudIconButton
                                Icon="@Icons.Material.Filled.Loop"
                                Disabled="@(character.SplinterPoints.Used == 0)"
                                OnClick="resetSplinterPointsAsync"
                            />
                        </MudTooltip>
                    }
                    <MudTabs
                        KeepPanelsAlive="true"
                        TabPanelClass="CharacterTab">
                        <PoolEditor
                            Title="Leben"
                            Icon="@Icons.Material.Filled.Shield"
                            TotalCapacity="@(c => c * 5)"
                            LineCapacity="@(c => c)"
                            Pool="@character.Lp"
                            ShowPenalties
                            Type="@PoolType.Lp"
                            Permissions="@Permissions"/>
                        <PoolEditor
                            Title="Fokus"
                            Icon="@Icons.Material.Filled.Nightlight"
                            TotalCapacity="@(c => c)"
                            LineCapacity="@(_ => 12)"
                            Pool="@character.Fo"
                            Type="@PoolType.Fo"
                            Permissions="@Permissions"/>
                    </MudTabs>
            </MudCardContent>
        </MudCard>
    </CascadingValue>
}

@code {

    [Parameter]
    [EditorRequired]
    public required ICharacterHandle CharacterHandle { get; set; }
    
    [Parameter]
    [EditorRequired]
    public required CharacterPermissions Permissions { get; set; }

    [CascadingParameter]
    public required ICharacterCommandRouter OuterCommandRouter { get; set; }

    ICharacterHandle? lastHandle;

    Character character => CharacterHandle.Character;

    IImmutableDictionary<string, ActionShorthand> newShorthands = ImmutableDictionary<string, ActionShorthand>.Empty;

    protected override void OnParametersSet()
    {
        clearHandleCallbacks();

        base.OnParametersSet();
        lastHandle = CharacterHandle;
        CharacterHandle.Updated += handleUpdated;
    }

    public void Dispose()
    {
        clearHandleCallbacks();
    }

    void clearHandleCallbacks()
    {
        if (lastHandle is { } prevHandle)
        {
            prevHandle.Updated -= handleUpdated;
        }

        if (CharacterHandle is { } handle)
        {
            handle.Updated -= handleUpdated;
        }
    }

    void handleUpdated(object? sender, EventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    [SuppressMessage("ReSharper", "WithExpressionModifiesAllMembers")]
    public async Task ApplyAsync(ICharacterCommand command)
    {
        command = command switch {
            ApplyPoints applyPoints => applyPoints with{ CharacterId = character.Id},
            Domain.Commands.StopChanneling releaseChanneling => releaseChanneling with { CharacterId = character.Id},
            Domain.Commands.ShortRest shortRest => shortRest with { CharacterId = character.Id},
            UseSplinterPoints useSplinterPoints => useSplinterPoints with {CharacterId = character.Id },
            ResetSplinterPoints resetSplinterPoints => resetSplinterPoints with {CharacterId = character.Id },
            _ => throw new ArgumentOutOfRangeException(nameof(command))
            };
        await OuterCommandRouter.ApplyAsync(command);
    }
    
    async Task useSplinterPointAsync()
    {
        await ApplyAsync(new UseSplinterPoints(null!, 1));
    }
    
    async Task resetSplinterPointsAsync() 
    {
        await ApplyAsync(new ResetSplinterPoints(null!));
    }

    void gotoEdit()
    {
        nav.NavigateTo($"/Characters/{character.ImplicitId}/Edit");
    }

}