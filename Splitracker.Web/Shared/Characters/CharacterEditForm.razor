@using Splitracker.Domain
@using MudBlazor.Utilities
@using System.Collections.Immutable
@using System.Timers
@using Splitracker.Domain.Commands

<MudBreadcrumbs
    Items="@( [new("Charaktere", "/", icon: Icons.Material.Filled.EmojiPeople!), new(character.Name, null, disabled: true)])"/>

@{
    var row = 1;
}

<div
    class="editor">
    @* Name *@
    <div
        class="full"
        style="@($"grid-row: {row++}")">
        <MudTextField
            @bind-Value="newName"
            Label="Name"
            Required
            Immediate="@true"
            RequiredError="Jeder braucht einen Namen!"/>
    </div>
    @* LP *@
    <div
        class="default-control"
        style="@($"grid-row: {row}")">
        <MudNumericField
            Label="LP"
            @bind-Value="newLpBaseCapacity"
            Min="1"
            Max="20"
            Required/>
    </div>
    <MudText
        Class="outcome"
        Style="@($"grid-row: {row++}")">
        =&nbsp;@(newLpBaseCapacity * 5)
    </MudText>
    @* FO *@

    <div
        class="default-control"
        style="@($"grid-row: {row++}")">
        <MudNumericField
            Label="FO"
            @bind-Value="newFoBaseCapacity"
            Min="1"
            Max="@(12 * 6)"
            Required/>
    </div>

    @* Splinter Points *@

    <div
        class="default-control"
        style="@($"grid-row: {row++}")">
        <MudNumericField
            Label="Splitterpunkte"
            @bind-Value="newSplinterPointMaximum"
            Min="0"
            Max="9"
            Required/>
    </div>

    @* Color *@

    <MudCheckBox
        Style="@($"grid-row: {row}; grid-column: 1")"
        T="bool"
        @bind-Checked="newHasCustomColor"/>
    <div
        style="@($"grid-row: {row}; grid-column: 2/4")"
        @onclick="() => { if (!newHasCustomColor) newHasCustomColor = true; }">
        <MudColorPicker
            Disabled="@(!newHasCustomColor)"
            Label="Avatar Farbe"
            @bind-Value="newColor"
            DisableAlpha="@true"
            PickerVariant="PickerVariant.Inline"
            ColorPickerMode="ColorPickerMode.RGB"/>
    </div>
    <div
        class="outcome"
        style="grid-row: @(row++)">
        <CharacterAvatar
            Elevation="2"
            Selected="@dummyAvatarPreviewSelected"
            OnClick="@(() => dummyAvatarPreviewSelected = !dummyAvatarPreviewSelected)"
            Character="@(character with { CustomColor = newHasCustomColor ? newColor?.ToString(MudColorOutputFormats.Hex) : null })"/>
    </div>

    @* Actions *@
    <ActionShorthandListEditor
        @bind-Shorthands="newShorthands"
        StartRow="@(row)"
        Type="ActionShorthandType.Melee"/>
    @{ row += 3; }
    <ActionShorthandListEditor
        @bind-Shorthands="newShorthands"
        StartRow="@(row)"
        Type="ActionShorthandType.Ranged"/>
    @{ row += 4; }
    <ActionShorthandListEditor
        @bind-Shorthands="newShorthands"
        StartRow="@(row)"
        Type="ActionShorthandType.Spell"/>
    @{ row += 4; }
    @* Opponent *@
    <div
        style="@($"grid-row: {row}")"
        class="default-control">
        <MudTooltip
            Text="(Für Spielleiter)">
            <MudSwitch
                T="bool"
                UnCheckedColor="Color.Default"
                Color="Color.Error"
                @bind-Checked="newIsOpponent"
                Label="Ist Gegner*in"/>
        </MudTooltip>
    </div>
    <div
        class="full">
        <MudStack
            Row
            AlignItems="AlignItems.Center"
            Justify="Justify.SpaceEvenly">
            @if (character.Id != "")
            {
                <MudButton
                    EndIcon="@Icons.Material.Filled.DeleteForever"
                    Color="@Color.Secondary"
                    @onclick="deleteAsync">
                    Löschen
                </MudButton>
                <MudButton
                    EndIcon="@Icons.Material.Filled.ContentCopy"
                    Color="@Color.Tertiary"
                    @onclick="cloneAsync"
                    Disabled="@hasChanges">
                    Klonen
                </MudButton>
            }
            <MudButton
                EndIcon="@Icons.Material.Filled.Save"
                Disabled="@(!hasChanges)"
                Color="@Color.Primary"
                @onclick="saveAsync">
                Speichern
            </MudButton>
        </MudStack>
    </div>

</div>

@code {

    [Parameter]
    [EditorRequired]
    public required Character Character { get; set; }

    [Parameter]
    [EditorRequired]
    public required CharacterPermissions Permissions { get; set; }

    Character character => Character;

    [CascadingParameter]
    public required ICharacterCommandRouter OuterCommandRouter { get; set; }

    string newName = string.Empty;
    int newLpBaseCapacity;
    int newFoBaseCapacity;
    int newSplinterPointMaximum;
    bool newIsOpponent;
    MudColor? newColor;
    bool newHasCustomColor;
    IImmutableDictionary<string, ActionShorthand> newShorthands = ImmutableDictionary<string, ActionShorthand>.Empty;

    bool dummyAvatarPreviewSelected = false;

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        
        newName = character.Name;
        newLpBaseCapacity = character.Lp.BaseCapacity;
        newFoBaseCapacity = character.Fo.BaseCapacity;
        newSplinterPointMaximum = character.SplinterPoints.Max;
        newColor = character.CustomColor is not null ? new MudColor(character.CustomColor) : "#000000";
        newHasCustomColor = character.CustomColor is not null;
        newIsOpponent = character.IsOpponent;
        newShorthands = character.ActionShorthands;
    }

    private bool hasChanges =>
        character.Id == ""
        || newName != character.Name
        || newLpBaseCapacity != character.Lp.BaseCapacity
        || newFoBaseCapacity != character.Fo.BaseCapacity
        || newSplinterPointMaximum != character.SplinterPoints.Max
        || newIsOpponent != character.IsOpponent
        || (newHasCustomColor && newColor?.ToString(MudColorOutputFormats.Hex) != character.CustomColor)
        || (!newHasCustomColor && character.CustomColor is not null)
        || !newShorthands.SequenceEqual(character.ActionShorthands);

    async Task saveAsync()
    {
        await OuterCommandRouter.ApplyAsync(new EditCharacter(
            null!,
            newName,
            newLpBaseCapacity,
            newFoBaseCapacity,
            newSplinterPointMaximum,
            newHasCustomColor && newColor != null
                ? newColor.ToString(MudColorOutputFormats.Hex)
                : null,
            newShorthands,
            newIsOpponent,
            []));
    }

    async Task deleteAsync()
    {
        await OuterCommandRouter.ApplyAsync(new DeleteCharacter(null!));
    }

    async Task cloneAsync()
    {
        await OuterCommandRouter.ApplyAsync(new CloneCharacter(null!));
    }

}