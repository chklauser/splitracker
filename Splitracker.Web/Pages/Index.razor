@page "/"
@using Splitracker.Domain
@using Splitracker.Domain.Commands
@using Splitracker.Web.Shared.Characters
@using System.Collections.Immutable
@implements IAsyncDisposable
@implements ICharacterCommandRouter

@inject ICharacterRepository repository

<PageTitle>Charaktere | Splitracker</PageTitle>

<MudBreadcrumbs
    Items="breadcrumbs"/>

<SectionContent
    Name="top">
    <MudPaper
        Elevation="1"
        Class="mx-6 pl-6">
        <MudSwitch
            T="bool"
            @bind-Checked="editMode">
            <MudIcon
                Icon="@Icons.Material.Filled.ModeEdit"
                Color="@(editMode ? Color.Tertiary : Color.Default)"/>
        </MudSwitch>
    </MudPaper>
</SectionContent>

<div
    class="d-flex flex-row flex-wrap gap-4">
    @if (handle is {} repositoryHandle)
    {
        <CascadingValue
            TValue="ICharacterCommandRouter"
            IsFixed="true"
            Value="@this">
            @foreach (var characterHandle in repositoryHandle.Characters)
            {
                <CharacterCard
                    @key="characterHandle.Character.Id"
                    CharacterHandle="@characterHandle"
                    Permissions="@characterPermissions[characterHandle.Character.Id]"
                    EditMode="@editMode"/>
            }
        </CascadingValue>
    }
    else
    {
        <CharacterCardSkeleton/>
    }
    @if (newCharacter != null)
    {
        <CascadingValue
            TValue="ICharacterCommandRouter"
            IsFixed="@true"
            Value="@newCharacterRouter">
            <CharacterCard
                EditMode="@true"
                CharacterHandle="@newCharacterRouter"
                Permissions="@Permissions.OwnerPermissions"
                />
        </CascadingValue>
    }
    @if (newCharacter == null && handle is {Characters.Count: 0 })
    {
        <MudText>
            Hier werden deine Charaktere angezeigt. Wie es scheint, hast du aber im Moment noch keine Charaktere.
            Klick auf den schwebenden runden Knopf unten rechts, um einen neuen Charakter anzulegen.
        </MudText>
    }
</div>

@if (newCharacter == null)
{
    <MudFab
        Class="fixed z-100"
        Style="right: 1.5rem; bottom: 1.5rem;"
        DisableRipple="@true"
        StartIcon="@Icons.Material.Filled.Add"
        Color="@Color.Primary"
        @onclick="addCharacterForm"/>
}

@code {

    public Index()
    {
        newCharacterRouter = new(this);
    }
    
    List<BreadcrumbItem> breadcrumbs => new() { new("Charaktere", "/", icon: Icons.Filled.EmojiPeople!) };

    [CascadingParameter]
    public required Task<AuthenticationState> AuthenticationState { get; set; }
    
    [CascadingParameter]
    public required IPermissionService Permissions { get; set; }

    ICharacterRepositoryHandle? handle;
    IImmutableDictionary<string, CharacterPermissions> characterPermissions = ImmutableDictionary<string, CharacterPermissions>.Empty;

    Character? newCharacter;

    private bool editMode;

    protected override async Task OnParametersSetAsync()
    {
        if (handle != null)
        {
            await handle.DisposeAsync();
        }
        handle = null;
        StateHasChanged();

        await base.OnInitializedAsync();
        var auth = await AuthenticationState;
        handle = await repository.OpenAsync(auth.User);
        handle.CharacterAdded += (_, _) => InvokeAsync(onCharacterListUpdated);
        handle.CharacterDeleted += (_, _) => InvokeAsync(onCharacterListUpdated);
        refreshCharacterPermissions();
    }

    void refreshCharacterPermissions()
    {
        characterPermissions = handle?.Characters.ToImmutableDictionary(
            c => c.Character.Id,
            c => Permissions.OnTheCharacterScreen(c.Character)
            ) ?? ImmutableDictionary<string, CharacterPermissions>.Empty;
    }

    void onCharacterListUpdated()
    {
        refreshCharacterPermissions();
        StateHasChanged();
    }
    
    public async ValueTask DisposeAsync()
    {
        if (handle != null)
        {
            await handle.DisposeAsync();
        }
    }

    public async Task ApplyAsync(ICharacterCommand command)
    {
        var state = await AuthenticationState;
        await repository.ApplyAsync(state.User, command);
    }

    void addCharacterForm()
    {
        newCharacter = new("", "Dein Name", 5, 10, 
            actionShorthands: new Dictionary<string, ActionShorthand>() {
                {"melee", new("melee", "Nahkampf Ang.", null, 7, ActionShorthandType.Melee, null) },
                {"ranged", new("ranged", "Fernkampf Vorb.", null, 4, ActionShorthandType.Ranged, null) },
                {"focus", new("focus", "Fokus", null, 4, ActionShorthandType.Spell, null) },
            }.ToImmutableDictionary());
    }

    private readonly NewCharacterRouter newCharacterRouter;
    class NewCharacterRouter : ICharacterCommandRouter, ICharacterHandle
    {
        readonly Index inner;

        public NewCharacterRouter(Index inner)
        {
            this.inner = inner;
        }

        public async Task ApplyAsync(ICharacterCommand command)
        {
            switch (command)
            {
                case DeleteCharacter:
                    inner.newCharacter = null;
                    inner.StateHasChanged();
                    break;
                case EditCharacter edit:
                    await inner.ApplyAsync(new CreateCharacter(
                        edit.Name,
                        edit.LpBaseCapacity, 
                        edit.FoBaseCapacity,
                        edit.CustomColor,
                        edit.ActionShorthands,
                        edit.IsOpponent));
                    inner.newCharacter = null;
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(command), "Unexpected command type: " + command.GetType());
            }
        }

        public Character Character => inner.newCharacter ?? new Character(null!, "", 1, 1);
        event EventHandler? ICharacterHandle.CharacterUpdated
        {
            add { }
            remove { }
        }
    }
}